********************************************************************************
$ontext

   DairyDyn project

   GAMS file : UAPPROX.GMS

   @purpose  : Report statistics on approximation of Utility function
   @author   : W.Britz
   @date     : 28.11.21
   @since    :
   @refDoc   :
   @seeAlso  :
   @calledBy :

$offtext
********************************************************************************
$ifi not "%RiskModel%"=="Estimated utility function" $exit

$iftheni.uApp defined v_uApproxN
  parameter p_Checku(*,*),p_distPay(*,*);
*
* --- probability
*
  p_Checku(nCur,"objProb")           = p_probn(nCur);
  p_Checku(nCur,"subProb")           = sum(nCur1,v_permMat(nCur1,nCur)*p_weights(nCur1));
*
* --- Household income in each future (= payoff)
*
  p_Checku(nCur,"payOffNeutral") = v_objeN.scale(nCur);

*
* --- utility from risk neutral solution
*
  p_Checku(nCur,"utilNeutral") =               [( v_objeN.scale(nCur)-p_refPoint)**%TKAlpha%] $ ((v_objeN.scale(nCur)- p_refPoint) gt 0)
                                  %TKgamma%  * [(-v_objeN.scale(nCur)+p_refPoint)**%TKBeta% ] $ ((v_objeN.scale(nCur)- p_refPoint) lt 0) + eps;
*
* --- pay-off under CPT
*
  p_Checku(nCur,"payOffCPT")  = v_objeN(nCur);
*
* --- utility from the TK function of the pay-offs under CPT
*
  p_Checku(nCur,"utilCPT") =              [( v_objeN(nCur)-p_refPoint)**%TKAlpha%] $ ((v_objeN(nCur)- p_refPoint) gt 0)
                             %TKgamma%  * [(-v_objeN(nCur)+p_refPoint)**%TKBeta% ] $ ((v_objeN(nCur)- p_refPoint) lt 0) + eps;
*
* --- simulated approximated utility under CPT
*
  p_Checku(nCur,"utilApprCPT") = v_uApproxN(nCur);
*
* --- absolute/relative error of approximation with correction for wrong slacks
*
  p_Checku(nCur,"dApprErr")   = p_Checku(nCur,"utilCPT")-p_Checku(nCur,"utilApprCPT");
  p_Checku(nCur,"dApprErr")    $ (abs(p_Checku(nCur,"dApprErr")) le 1.E-6) = 0;
  p_Checku(nCur,"%ApprErr") $ (p_Checku(nCur,"utilCPT") ne eps)  = p_Checku(nCur,"dApprErr") /p_Checku(nCur,"utilCPT")*100;
*
* --- averages (errors absolute)
*
  set UAve /  objProb,payOffNeutral,utilNeutral,payOffCPT,utilCPT,utilApprCPT /;

  p_Checku("subjAve",UAve)        = sum(nCur, p_Checku(nCur,"subProb")    *p_Checku(nCur,UAve));
  p_Checku("objAve",UAve)         = sum(nCur, p_probn(nCur)*p_Checku(nCur,UAve));
  p_Checku("subjAve","dApprErr")  = sum(nCur, p_Checku(nCur,"subProb")    *abs(p_Checku(nCur,"dApprErr")));
  p_Checku("subjAve","%ApprErr")  = sum(nCur, p_Checku(nCur,"subProb")    *abs(p_Checku(nCur,"%ApprErr")));

  p_Checku(nCur,"inDem")  = sum((crops,sys,t_n(t,nCur)) $ p_resIns(crops,sys,"inDem",t,nCur), p_resIns(crops,sys,"inDem",t,nCur)*v_buyCropIns(crops,sys,t));
*
* execute_unload "c:\scrdir\checku" p_checkU;


  set futures / f1*f%nLeaves% /;
  set futures_n(futures,n);
  scalar iFut / 0 /;
  loop(nCur,
     iFut = iFut + 1;
     futures_n(futures,nCur) $ (futures.pos eq iFut) = YES;
  );

  set copFut / payOffCPT,payOffNeutral,utilCpt,utilNeutral /;

  parameter tmp(futures),index(futures);
  loop(copFut,

      tmp(futures) = sum(futures_n(futures,nCur),p_checkU(nCur,copFut));
      embeddedCode Python:
         tmp = sorted(gams.get("tmp"), key=lambda x:x[-1])
         index = [(rec[0], idx+1) for rec,idx in zip(tmp, range(len(tmp))) ]
         gams.set("index",index)
      pauseEmbeddedCode index


      p_sumRes(futures + [index(futures) - ord(futures)] ,copFut) = tmp(futures);
  );

  display p_checkU;
$endif.uApp



