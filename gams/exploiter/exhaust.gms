********************************************************************************
$ontext

   FARMDYN project

   GAMS file : EXHAUST.GMS

   @purpose  : Use CONVERT output (dict.txt, dump.gdx) to generate
               an dual exhaustion report for all variables
   @author   : W.Britz
   @date     : 06.02.21
   @since    :
   @refDoc   :
   @seeAlso  :
   @calledBy :

$offtext
********************************************************************************
$$offlisting
$if not setglobal dumpfile    $setglobal dumpfile    'c:\scrdir\dump.gdx'
$if not setglobal dictfile    $setglobal dictfile    'c:\scrdir\dict.txt'
$if not setglobal gdxfilename $setglobal gdxfileName 'c:\dairydyn\results\expFarms\res_enterName.gdx'
*
* --- set load to true to merge the output with parameters already in the GDX
*
$if not setglobal load        $setglobal load true



set j "Numbered variable names"
    i "Numbered equation names"

*
* --- read numbered names from CONVERT output
*
$GDXIN "%dumpfile%"
$LOAD j,i
$GDXIN

set

  varDim0(*)
  varDim1(*)
  varDim2(*)
  varDim3(*)
  varDim4(*)
  varDim5(*)
  varDim6(*)
  varDim7(*)
  varDim8(*)
  varDim9(*)

  equDim0(*)
  equDim1(*)
  equDim2(*)
  equDim3(*)
  equDim4(*)
  equDim5(*)
  equDim6(*)
  equDim7(*)
  equDim8(*)
  equDim9(*)

 jj(j,*)       "Cross set between numbered and variable names, name only"
 ii(i,*)       "Cross set between numbered and equation names, name only"
 ixx(*,*,i)    "Cross set between numbered and equation names, indexed"



 jName(*)      "Variable names, name only"
 iName(*)      "Equationn names, name only"
 iInd(*)       "Labels of incides, such ('ind1','ind2'.... )"
 i_iInd(*,*)    "Link between equation names and iInd"
;

*
* --- parse dictionary file and store maps between numbered and named
*     equations and variables
*
$onEmbeddedCode Python:

  import os

#
# -- count the max # of dimensions on any variable and any equation
#
  mode    = "none"
  maxNEqu = 0
  maxNVar = 0
  with open(r'%dictFile%', 'r') as f:
     for line in f:
         if ( line.startswith("Equations 1") ):
            mode = "Equations"
         elif ( line.startswith("Variables 1") ):
            mode = "Variables"
         else:
#
#           -- split line in dictionary file with has first the numbered name and next the full one
#
            words = line.split();
            if ( len(words) > 1 ):

               if ( (mode == "Equations") or (mode == "Variables") ):
#
#                 -- to avoid double "" replae by ''
#
                  words[1] = words[1].replace('"',"'")
                  index  = words[1].find('(')
                  if ( index > -1):
                     ind = words[1][index:].split(',')
                     n = len(ind)
                     if ( mode == "Equations" ):
                           maxNEqu = max(n,maxNEqu)
                     else:
                           maxNVar = max(n,maxNVar)
     f.close()

#
#    -- the total # of dimension on a GAMS symbol is 20. We need two dimensions
#       for the variable and equation names, and one for the report columns. That
#       leaves 17 to be distributed to variable and equations. Assign up to 10
#       for the variables. But if we want to use GDXDiff, we can only use 19 ...
#
     if ( maxNEqu + maxNVar > 16):
          maxNVar = min(maxNVar,10)
     os.environ["maxVar"] = str(maxNVar)

#
#    --- the resulting # of variable dimension plus the maximum dimension on any
#        variable exceeds 10, assign to equations, with a max of 10
#
     if ( maxNEqu + maxNVar > 16):
          maxNEqu = min(16 - maxNVar,10);
     os.environ["maxEqu"] = str(maxNEqu)

#
#    --- define strings for pyhton and gams via sting substitution which define
#        the mappings
#
     defVar ="";
     defVarStar ="";
     defVarDim ="";
     for i in range(0,maxNVar):
         defVar  = defVar+"varDim"+str(i)+","
         defVarStar = defVarStar+"*,"
         defVarDim = defVarDim+"varInd["+str(i)+"],"

     l = len(defVar)
     defVar = defVar[0:l-1]
     os.environ["defVar"] = defVar

     l = len(defVarStar)
     defVarStar = defVarStar[0:l-1]
     os.environ["defVarStar"] = defVarStar


     l = len(defVarDim)
     defVarDim = defVarDim[0:l-1]
     os.environ["defVarDim"] = defVarDim

     defEqu ="";
     defEquStar  ="";
     defEquDim   ="";
     defEquEmpty ="";
     for i in range(0,maxNEqu):
         defEqu  = defEqu+"equDim"+str(i)+","
         defEquStar  = defEquStar+"*,"
         defEquEmpty = defEquEmpty+"\"''\","
         defEquDim = defEquDim+"equInd["+str(i)+"],"

     l = len(defEqu)
     defEqu = defEqu[0:l-1]
     os.environ["defEqu"] = defEqu

     l = len(defEquStar)
     defEquStar = defEquStar[0:l-1]
     os.environ["defEquStar"] = defEquStar

     l = len(defEquEmpty)
     defEquEmpty = defEquEmpty[0:l-1]
     os.environ["defEquEmpty"] = defEquEmpty

     l = len(defEquDim)
     defEquDim = defEquDim[0:l-1]
     os.environ["defEquDim"] = defEquDim

$offEmbeddedCode


*
* --- the mapping steps have variable # of dimensions depending on the max. dimensions
*     for variabels / equation above
*
 set
 iii(*,%sysenv.defEquStar%,i)    "Cross set between numbered and equation names, indexed"
 eee(*,%sysenv.defEquStar%)      "Cross set between numbered and equation names, indexed"

 jjj(*,%sysenv.defVarStar%,j)    "Cross set between numbered and variable names, indexed"
 vvv(*,%sysenv.defVarStar%)      "Cross set between numbered and variable names, indexed"
 ;


$onEmbeddedCode Python:

  mode    = "none"
  iName   = []
#
#  --- add further fields for reports for each variables
#
  iName.append("marg")
  iName.append("test")
  iName.append("level")

  jName   = []
  iInd = []
  iInd.append("")

  jjj = []
  vvv = []
  iii = []
  eee = []

  jj  = []
  ii  = []
  ixx = []
  i_iInd = set([])
  ji    = set([])

  varDim0 = []
  varDim1 = []
  varDim2 = []
  varDim3 = []
  varDim4 = []
  varDim5 = []
  varDim6 = []
  varDim7 = []
  varDim8 = []
  varDim9 = []

  equDim0 = []
  equDim0.append("''")

  equDim1 = []
  equDim1.append("''")

  equDim2 = []
  equDim2.append("''")

  equDim3 = []
  equDim3.append("''")

  equDim4 = []
  equDim4.append("''")

  equDim5 = []
  equDim5.append("''")

  equDim6 = []
  equDim6.append("''")

  equDim7 = []
  equDim7.append("''")

  equDim8 = []
  equDim8.append("''")

  equDim9 = []
  equDim9.append("''")

  with open(r'%dictFile%', 'r') as f:
     for line in f:
         if ( line.startswith("Equations 1") ):
            mode = "Equations"
         elif ( line.startswith("Variables 1") ):
            mode = "Variables"
         else:
#
#           -- split line in dictionary file with has first the numbered name and next the full one
#
            words = line.split();
            if ( len(words) > 1 ):

               if ( (mode == "Equations") or (mode == "Variables") ):
#
#                 -- to avoid double "" replae by ''
#
                  words[1] = words[1].replace('"',"'")
#
#                 --- labels, between brackets in name
#
                  index  = words[1].find('(')
                  indexL = words[1].find(')')
#
#                 --- no brackets found
#
                  if ( index == -1):
#
#                    --- scalar equation/variable, add empty index field
#
                     words.append("''")
                     words.append("''")
                     index = 63
                  else:
#
#                    --- add the part without the brackes as additional word
#
                     words.append(words[1][index+1:min(index+64,indexL)])
#
#                 --- symbol name (without labels for iInd)
#
                  words[1] = words[1][:index]

                  if ( mode == "Equations" ):
                     
                     words[2] = words[2].replace('"',"'")

                     ixx.append( (words[1],words[2],words[0]) )
                     ii.append( (words[0],words[1]) )
                     if ( words[1] not in iName):
                        iName.append ( words[1] )
                     i_iInd.add( (words[1],words[2]) )
#
#                    --- labels for indices
#
                     if ( words[2] not in iInd):
                        iInd.append(words[2])
#
#                    --- split the labels for the variable indices
#
                     equInd = words[2].split(',')
#
#                    --- # of indices
#
                     n = len(equInd)
#
#                    ---- if <10, append empty labels, if > 10, concatinate the additional ones and drop them
#
                     if ( n < %sysenv.maxEqu%):
                        for i in range(n,%sysenv.maxEqu%):
                            equInd.append("''")
                     elif ( n > %sysenv.maxEqu%):
                         for i in range(%sysenv.maxEqu%,n):
                            equInd[%sysenv.maxEqu%-1] = equInd[%sysenv.maxEqu%-1] + ","+ equInd[i]

                         for i in range(%sysenv.maxEqu%,n):
                            equInd.pop()
#
#                    --- add labels to the position 0-10 (up to maximal # of dimensions for any equation)
#
                     if ( equInd[0] not in equDim0):
                          equDim0.append(equInd[0])
                     if (%sysenv.maxEqu%>1 and  equInd[1] not in equDim1):
                                                equDim1.append(equInd[1])
                     if (%sysenv.maxEqu%>2 and  equInd[2] not in equDim2):
                                                equDim2.append(equInd[2])
                     if (%sysenv.maxEqu%>3 and  equInd[3] not in equDim3):
                                                equDim3.append(equInd[3])
                     if (%sysenv.maxEqu%>4 and  equInd[4] not in equDim4):
                                                equDim4.append(equInd[4])
                     if (%sysenv.maxEqu%>5 and  equInd[5] not in equDim5):
                                                equDim5.append(equInd[5])
                     if (%sysenv.maxEqu%>6 and  equInd[6] not in equDim6):
                                                equDim6.append(equInd[6])
                     if (%sysenv.maxEqu%>7 and  equInd[7] not in equDim7):
                                                equDim7.append(equInd[7])
                     if (%sysenv.maxEqu%>8 and  equInd[8] not in equDim8):
                                                equDim8.append(equInd[8])
                     if (%sysenv.maxEqu%>9 and equInd[9] not in equDim9):
                                                equDim9.append(equInd[9])
#
#                    --- cross-set between variable names, the up to 10 index labels, and the scalar variable name
#
                     iii.append ( (words[1],%sysenv.defEquDim%,words[0]) )

#
#                    --- cross-set between variable names, the up to 10 index labels
#
                     if ( (words[1],%sysenv.defEquDim%) not in eee):
                        eee.append( (words[1],%sysenv.defEquDim%) )

                  elif ( mode == "Variables" ):
#
#                    --- split the labels for the variable indices
#
                     varInd = words[2].split(',')
#
#                    --- # of indices
#
                     n = len(varInd)
#
#                    ---- if <10, append empty labels, if > 10, concatinate the additional ones and drop them
#
                     if ( n < %sysenv.maxVar%):
                        for i in range(n,%sysenv.maxVar%):
                            varInd.append("''")
                     elif ( n > %sysenv.maxVar%):
                         for i in range(%sysenv.maxVar%,n):
                            varInd[%sysenv.maxVar%-1] = varInd[%sysenv.maxVar%-1] + ","+ varInd[i]

                         for i in range(%sysenv.maxVar%,n):
                            varInd.pop()
#
#                    --- add labels to the position 0-10  (up to maximal # of dimensions for any variable)
#
                     if ( varInd[0] not in varDim0):
                          varDim0.append(varInd[0])
                     if ( %sysenv.maxVar%>1 and varInd[1] not in varDim1):
                                                varDim1.append(varInd[1])
                     if ( %sysenv.maxVar%>2 and varInd[2] not in varDim2):
                                                varDim2.append(varInd[2])
                     if ( %sysenv.maxVar%>3 and varInd[3] not in varDim3):
                                                varDim3.append(varInd[3])
                     if ( %sysenv.maxVar%>4 and varInd[4] not in varDim4):
                                                varDim4.append(varInd[4])
                     if ( %sysenv.maxVar%>5 and varInd[5] not in varDim5):
                                                varDim5.append(varInd[5])
                     if ( %sysenv.maxVar%>6 and varInd[6] not in varDim6):
                                                varDim6.append(varInd[6])
                     if ( %sysenv.maxVar%>7 and varInd[7] not in varDim7):
                                                varDim7.append(varInd[7])
                     if ( %sysenv.maxVar%>8 and varInd[8] not in varDim8):
                                                varDim8.append(varInd[8])
                     if ( %sysenv.maxVar%>9 and varInd[9] not in varDim9):
                                                varDim9.append(varInd[9])
#
#                    --- cross-set between variable names, the up to 10 index labels, and the scalar variable name
#
                     jjj.append ( (words[1],%sysenv.defVarDim%,words[0]) )

#
#                    --- cross-set between variable names, the up to 10 index labels
#
                     if ( (words[1],%sysenv.defVarDim%) not in vvv):
                        vvv.append( (words[1],%sysenv.defVarDim%) )
#
#                    --- cross-set between variable and equation names
#
                     jj.append( (words[0],words[1]) )
                     if ( words[1] not in jName):
                        jName.append ( words[1] )

     f.close()
#
#  --- add generated lists / sets to GAMS data base
#
  gams.set("iName",iName)
  gams.set("jName",jName)
  gams.set("jj",jj)
  gams.set("ii",ii)
  gams.set("ixx",ixx)
  gams.set("jjj",jjj)
  gams.set("vvv",vvv)
  gams.set("iii",iii)
  gams.set("eee",eee)
  gams.set("iInd",iInd)
  gams.set("i_iInd",i_iInd)

  gams.set("varDim0",varDim0)
  gams.set("varDim1",varDim1)
  gams.set("varDim2",varDim2)
  gams.set("varDim3",varDim3)
  gams.set("varDim4",varDim4)
  gams.set("varDim5",varDim5)
  gams.set("varDim6",varDim6)
  gams.set("varDim7",varDim7)
  gams.set("varDim8",varDim8)
  gams.set("varDim9",varDim9)

  gams.set("equDim0",equDim0)
  gams.set("equDim1",equDim1)
  gams.set("equDim2",equDim2)
  gams.set("equDim3",equDim3)
  gams.set("equDim4",equDim4)
  gams.set("equDim5",equDim5)
  gams.set("equDim6",equDim6)
  gams.set("equDim7",equDim7)
  gams.set("equDim8",equDim8)
  gams.set("equDim9",equDim9)

$offEmbeddedCode iName jName jj ii ixx vvv jjj eee iii iInd i_iInd varDim0 varDim1 varDim2 varDim3 varDim4 varDim5 varDim6 varDim7 varDim8 varDim9 equDim0 equDim1 equDim2 equDim3 equDim4 equDim5 equDim6 equDim7 equDim8 equDim9

*
* --- read the variables, equations, jacobian
*     from CONVERT output
*
  variable  x(j)   "Variables, numbered";
  equations e(i)   "Equations, numbered";
  parameter A(i,j) "Jacobian, numbered";
*
* --- load results for numbered vars,equations and the jacobian
*
  execute_load "%dumpfile%" x,e,A;

  parameter p_exhaust(jName,%sysEnv.defVar%,iName,%sysEnv.defEqu%,*);

*
* --- build cross sets between symbol names
*
  set j_i_name(jName,iName);
  j_i_name(jName,iName) $ sum( ( ii(i,iName),jj(j,jName)),A(i,j)) = YES;
*
* --- report variable level (stored in "A*M" column)
*
  p_exHaust(vvv(jName,%sysEnv.defVar%),"level",%sysenv.defEquEmpty%,"A*M")
     = sum(jjj(jName,%sysEnv.defVar%,j), x.l(j));
*
* --- report javobian on field "A"
*
  p_exhaust(vvv(jName,%sysEnv.defVar%),eee(iName,%sysEnv.defEqu%),"A") $ j_i_name(jName,iName)
    = sum( (jjj(jName,%sysEnv.defVar%,j),iii(iName,%sysEnv.defEqu%,i)) $ A(i,j), A(i,j));
*
* -- report marginal on field "M"
*
  p_exhaust(vvv(jName,%sysEnv.defVar%),eee(iName,%sysEnv.defEqu%),"m")
      $ (p_exhaust(jName,%sysEnv.defVar%,iName,%sysEnv.defEqu%,"A") $ j_i_name(jName,iName))
    = sum( (jjj(jName,%sysEnv.defVar%,j),
           iii(iName,%sysEnv.defEqu%,i)) $ (abs(e.m(i)) gt eps), e.m(i) );
*
* -- calculation contribution of dual exhaustion based on "A*M"
*
  p_exhaust(vvv(jName,%sysEnv.defVar%),eee(iName,%sysEnv.defEqu%),"A*M")

      $ (p_exhaust(jName,%sysEnv.defVar%,iName,%sysEnv.defEqu%,"m") $ j_i_name(jName,iName))
    =  p_exhaust(jName,%sysEnv.defVar%,iName,%sysEnv.defEqu%,"A")
     * p_exhaust(jName,%sysEnv.defVar%,iName,%sysEnv.defEqu%,"m");
*
* --- add sum of all entries for same equation symbol (= unique name), if more than one entry
*
  set AM /A,"A*M"/;

  p_exhaust(vvv(jName,%sysEnv.defVar%),iName,%sysenv.defEquEmpty%,AM)
   $ ( ( sum(eee(iName,%sysEnv.defEqu%)
                  $ p_exhaust(jName,%sysEnv.defVar%,iName,%sysEnv.defEqu%,AM),1) gt 1)
                               $ (not p_exhaust(jName,%sysEnv.defVar%,iName,%sysenv.defEquEmpty%,AM))
                               $ j_i_name(jName,iName) )
      = sum(eee(iName,%sysEnv.defEqu%),p_exhaust(jName,%sysEnv.defVar%,iName,%sysEnv.defEqu%,AM));
*
* --- average marginal over the Jacobian of one variable in the different indices
*     of an equation
*
  p_exhaust(vvv(jName,%sysEnv.defVar%),iName,%sysenv.defEquEmpty%,"M")
    $ p_exhaust(jName,%sysEnv.defVar%,iName,%sysenv.defEquEmpty%,"A")
      =  p_exhaust(jName,%sysEnv.defVar%,iName,%sysenv.defEquEmpty%,"A*M")
       / p_exhaust(jName,%sysEnv.defVar%,iName,%sysenv.defEquEmpty%,"A");
*
* --- add marginal value for variable (from hitting bounds, on "A*M" field
*
  p_exHaust(vvv(jName,%sysEnv.defVar%),"marg",%sysenv.defEquEmpty%,"A*M")
     = sum( jjj(jName,%sysEnv.defVar%,j), x.m(j));
*
* --- test exhaustion (= FOC) by adding up over "A*M" for all Jacobian entries
*     plus the marginal value
*
  p_exHaust(vvv(jName,%sysEnv.defVar%),"test",%sysenv.defEquEmpty%,"A*M")
   = sum( iii(iName,%sysEnv.defEqu%,i) $ j_i_name(jName,iName),
           p_exhaust(jName,%sysEnv.defVar%,iName,%sysEnv.defEqu%,"A*M"))
         + p_exHaust(jName,%sysEnv.defVar%,"marg",%sysenv.defEquEmpty%,"A*M");
*
* --- delete dual infeasibilities below 1.E-10 in absolute terms
*
  p_exHaust(vvv(jName,%sysEnv.defVar%),"test",%sysenv.defEquEmpty%,"A*M")
     $ (abs(p_exHaust(jName,%sysEnv.defVar%,"test",%sysenv.defEquEmpty%,"m")) le 1.E-10) = 0;

$iftheni.load "%load%"=="true"
*
* --- the following code will add the p_exhaust parameter to an existing GDX
*

$call gdxdump %gdxfilename% symbols > %gams.scrdir%dump.txt

$onembeddedCode Python:
   import os
   symbols =""
   symbols_def =""

   iLine = 0
   with open(r'%gams.scrdir%dump.txt', 'r') as f:
     for line in f:
         iLine = iLine + 1
         if ( iLine > 1):
            words = line.split();
            if ( not words[1] == "p_exhaust"):
               symbols = symbols +" "+words[1]
               if ( words[3] == "Par"):
                  words[3] = "parameter"
               symbols_def = symbols_def +" "+words[3]+" "+words[1]+";"

     f.close()
     os.environ["symbolsToLoad"] = symbols
     os.environ["symbolsToDef"]  = symbols_def

$offembeddedCode

%sysenv.symbolsToDef%
$onUNDF
$GDXIN %gdxFileName%
$LOAD  %sysenv.symbolsToLoad%
$GDxIN

  execute_unload "%gdxfileName%" %sysenv.SymbolsToLoad% p_exHaust;

$else.load

  execute_unload "%gdxfileName%" p_exHaust;
$endif.load
